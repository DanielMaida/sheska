A Study on Neural Network Language Modeling
Dengliang Shi dengliang.shi@yahoo.com
Shanghai, Shanghai, China
Abstract
An exhaustive study on neural network language modeling (NNLM) is performed in this
paper. Different architectures of basic neural network language models are described and
examined. A number of different improvements over basic neural network language mod-
els, including importance sampling, word classes, caching and bidirectional recurrent neural
network (BiRNN), are studied separately, and the advantages and disadvantages of every
technique are evaluated. Then, the limits of neural network language modeling are ex-
plored from the aspects of model architecture and knowledge representation. Part of the
statistical information from a word sequence will loss when it is processed word by word
in a certain order, and the mechanism of training neural network by updating weight ma-
trixes and vectors imposes severe restrictions on any significant enhancement of NNLM. For
knowledge representation, the knowledge represented by neural network language models is
the approximate probabilistic distribution of word sequences from a certain training data
set rather than the knowledge of a language itself or the information conveyed by word
sequences in a natural language. Finally, some directions for improving neural network
language modeling further is discussed.
Keywords: neural network language modeling, optimization techniques, limits, improve-
ment scheme
1. Introduction
Generally, a well-designed language model makes a critical difference in various natural
language processing (NLP) tasks, like speech recognition (Hinton et al., 2012; Graves et al.,
2013a), machine translation (Cho et al., 2014a; Wu et al., 2016), semantic extraction (Col-
lobert and Weston, 2007, 2008) and etc. Language modeling (LM), therefore, has been the
research focus in NLP field all the time, and a large number of sound research results have
been published in the past decades. N-gram based LM (Goodman, 2001a), a non-parametric
approach, is used to be state of the art, but now a parametric method - neural network
language modeling (NNLM) is considered to show better performance and more potential
over other LM techniques, and becomes the most commonly used LM technique in multiple
NLP tasks.
Although some previous attempts (Miikkulainen and Dyer, 1991; Schmidhuber, 1996;
Xu and Rudnicky, 2000) had been made to introduce artificial neural network (ANN) into
LM, NNLM began to attract researches’ attentions only after Bengio et al. (2003) and did
not show prominent advantages over other techniques of LM until recurrent neural net-
work (RNN) was investigated for NNLM (Mikolov et al., 2010, 2011). After more than
a decade’s research, numerous improvements, marginal or critical, over basic NNLM have
been proposed. However, the existing experimental results of these techniques are not com-
c© Dengliang Shi.
ar
X
iv
:1
70
8.
07
25
2v
1 
 [
cs
.C
L
] 
 2
4 
A
ug
 2
01
7
D. Shi
parable because they were obtained under different experimental setups and, sometimes,
these techniques were evaluated combined with other different techniques. Another signifi-
cant problem is that most researchers focus on achieving a state of the art language model,
but the limits of NNLM are rarely studied. In a few works (Jozefowicz et al., 2016) on
exploring the limits of NNLM, only some practical issues, like computational complexity,
corpus, vocabulary size, and etc., were dealt with, and no attention was spared on the
effectiveness of modeling a natural language using NNLM.
Since this study focuses on NNLM itself and does not aim at raising a state of the art
language model, the techniques of combining neural network language models with other
kind of language models, like N-gram based language models, maximum entropy (ME)
language models and etc., will not be included. The rest of this paper is organized as
follows: In next section, the basic neural network language models - feed-forward neural
network language model (FNNLM), recurrent neural network language model (RNNLM)
and long-short term memory (LSTM) RNNLM, will be introduced, including the training
and evaluation of these models. In the third section, the details of some important NNLM
techniques, including importance sampling, word classes, caching and bidirectional recurrent
neural network (BiRNN), will be described, and experiments will be performed on them
to examine their advantages and disadvantages separately. The limits of NNLM, mainly
about the aspects of model architecture and knowledge representation, will be explored
in the fourth section. A further work section will also be given to represent some further
researches on NNLM. In last section, a conclusion about the findings in this paper will be
made.
2. Basic Neural Network Language Models
The goal of statistical language models is to estimate the probability of a word sequence
w1w2...wT in a natural language, and the probability can be represented by the production
of the conditional probability of every word given all the previous ones:
P (wT1 ) =
T?
t=1
P (wt|wt?11 )
where, wji = wiwi+1 . . . wj?1wj . This chain rule is established on the assumption that
words in a word sequence only statistically depend on their previous context and forms
the foundation of all statistical language modeling. NNLM is a kind of statistical language
modeling, so it is also termed as neural probabilistic language modeling or neural statistical
language modeling. According to the architecture of used ANN, neural network language
models can be classified as: FNNLM, RNNLM and LSTM-RNNLM.
2.1 Feed-forward Neural Network Language Model, FNNLM
As mentioned above, the objective of FNNLM is to evaluate the conditional probability
P (wt|wt?11 ), but feed-forward neural network (FNN) lacks of an effective way to represent
history context. Hence, the idea of n-gram based LM is adopted in FNNLM that words in
a word sequence more statistically depend on the words closer to them, and only the n? 1
2
A Study on Neural Network Language Modeling
Figure 1: Feed-forward neural network language model
direct predecessor words are considered when evaluating the conditional probability, this is:
P (wt|wt?11 ) ? P (wt|w
t?1
t?n+1)
The architecture of the original FNNLM proposed by Bengio et al. (2003) is showed
in Figure 1, and w0, wT+1 are the start and end marks of a word sequence respectively.
In this model, a vocabulary is pre-built from a training data set, and every word in this
vocabulary is assigned with a unique index. To evaluate the conditional probability of word
wt, its n?1 direct previous words wt?n+1, ..., wt?1 are projected linearly into feature vectors
using a shared matrix C ? Rk×m according to their index in the vocabulary, where k is
the size of the vocabulary and m is the feature vectors’ dimension. In fact, every row of
projection matrix C is a feature vector of a word in the vocabulary. The input x ? Rni
of FNN is formed by concatenating the feature vectors of words wt?n+1, ..., wt?1, where
ni = m× (n? 1) is the size of FNN’s input layer. FNN can be generally represented as:
y = V · f(U · x + b) + M · x + d
Where, U ? Rnh×ni , V ? Rno×nh are weight matrixes, nh is the size of hidden layer, no = k
is the size of output layer, weight matrix M ? Rno×ni is for the direct connections between
input layer and output layer, b ? Rnh and d ? Rno are vectors for bias terms in hidden layer
and output layer respectively, y ? Rno is output vector, and f(·) is activation function.
The i-th element of output vector y is the unnormalized conditional probability of the
word with index i in the vocabulary. In order to guarantee all the conditional probabilities
of words positive and summing to one, a softmax layer is always adopted following the
output layer of FNN:
P (vi|wt?11 ) ? P (vi|w
t?1
t?n+1) =
ey(vi,w
t?1
t?n+1)?k
j=1 e
y(vj ,w
t?1
t?n+1)
, i = 1, 2, ..., k
where y(vi, w
t?1
t?n+1) (i = 1, 2, ..., k) is the i-th element of output vector y , and vi is the i-th
word in the vocabulary.
3
D. Shi
Training of neural network language models is usually achieved by maximizing the pe-
nalized log-likelihood of the training data:
L =
1
T
T?
t=1
log(P (wt|wt?11 ; ?)) + R(?)
where, ? is the set of model’s parameters to be trained, R(?) is a regularization term.
The recommended learning algorithm for neural network language models is stochastic
gradient descent (SGD) method using backpropagation (BP) algorithm. A common choice
for the loss function is the cross entroy loss which equals to negative log-likelihood here.
The parameters are usually updated as:
? = ? + ?
?L
??
? ??
where, ? is learning rate and ? is regularization parameter.
The performance of neural network language models is usually measured using perplexity
(PPL) which can be defined as:
PPL = T
???? T?
i=1
1
P (wi|wi?11 )
= 2?
1
T
?T
i=1 log2P (wi|w
i?1
1 )
Perplexity can be defined as the exponential of the average number of bits required to encode
the test data using a language model and lower perplexity indicates that the language model
is closer to the true model which generates the test data.
2.2 Recurrent Neural Network Language Model, RNNLM
The idea of applying RNN in LM was proposed much earlier (Bengio et al., 2003; Castro and
Prat, 2003), but the first serious attempt to build a RNNLM was made by Mikolov et al.
(2010, 2011). RNNs are fundamentally different from feed-forward architectures in the sense
that they operate on not only an input space but also an internal state space, and the state
space enables the representation of sequentially extended dependencies. Therefore, arbitrary
length of word sequence can be dealt with using RNNLM, and all previous context can be
taken into account when predicting next word. As showed in Figure 2, the representation
of words in RNNLM is the same as that of FNNLM, but the input of RNN at every step
is the feature vector of a direct previous word instead of the concatenation of the n ? 1
previous words’ feature vectors and all other previous words are taken into account by the
internal state of previous step. At step t, RNN can be described as:
st = f(U · x t + W · st?1 + b),
y t = V · st + M · x t + d
where, weight matrix W ? Rnh×nh , and the input layer’s size of RNN ni = m. The outputs
of RNN are also unnormalized probabilities and should be regularized using a softmax layer.
Because of the involvement of previous internal state at every step, back-propagation
through time (BPTT) algorithm (Rumelhart et al., 1986) is preferred for better performance
4
A Study on Neural Network Language Modeling
Figure 2: Recurrent neural network language model
when training RNNLMs. If data set is treated as a single long word sequence, truncated
BPTT should be used and back-propagating error gradient through 5 steps is enough, at
least for small corpus (Mikolov, 2012). In this paper, neural network language models will all
be trained on data set sentence by sentence, and the error gradient will be back-propagated
trough every whole sentence without any truncation.
2.3 Long Short Term Memory RNNLM, LSTM-RNNLM
Although RNNLM can take all predecessor words into account when predicting next word in
a word sequence, but it is quite difficult to be trained over long term dependencies because
of the vanishing or exploring problem (Hochreiter and Schmidhuber, 1997). LSTM-RNN
was designed aiming at solving this problem, and better performance can be expected by
replacing RNN with LSTM-RNN. LSTM-RNNLM was first proposed by Sundermeyer et al.
(2012), and the whole architecture is almost the same as RNNLM except the part of neural
network. LSTM-RNN was proposed by Hochreiter and Schmidhuber (1997) and was refined
and popularized in following works (Gers and Schmidhuber, 2000; Cho et al., 2014b). The
general architecture of LSTM-RNN is:
i t = ?(U i · x t + W i · st?1 + V i · ct?1 + bi)
f t = ?(U f · x t + W f · st?1 + V f · ct?1 + bf )
g t = f(U · x t + W · st?1 + V · ct?1 + b)
ct = f t ? ct?1 + i t ? g t
ot = ?(U o · x t + W o · st?1 + V o · ct + bo)
st = ot ? f(ct)
y t = V · st + M · x t + d
Where, i t, f t, ot ? Rnh are input gate, forget gate and output gate, respectively. ct ? Rnh
is the internal memory of unit. U i, U f , U o, U ? Rnh×ni , W i, W f , W o, W ? Rnh×nh ,
V i, V f , V o, V ? Rnh×nh are all weight matrixes. bi, bf , bo, b ? Rnh , and d ? Rno
5
D. Shi
are vectors for bias terms. f(·) is the activation function in hidden layer and ?(·) is the
activation function for gates.
2.4 Comparison of Neural Network Language Models
Comparisons among neural network language models with different architectures have al-
ready been made on both small and large corpus (Mikolov, 2012; Sundermeyer et al., 2013).
The results show that, generally, RNNLMs outperform FNNLMs and the best performance
is achieved using LSTM-NNLMs. However, the neural network language models used in
these comparisons are optimized using various techniques, and even combined with other
kind of language models, let alone the different experimental setups and implementation
details, which make the comparison results fail to illustrate the fundamental discrepancy in
the performance of neural network language models with different architecture and cannot
be taken as baseline for the studies in this paper.
Comparative experiments on neural network language models with different architecture
were repeated here. The models in these experiments were all implemented plainly, and
only a class-based speed-up technique was used which will be introduced later. Experiments
were performed on the Brown Corpus, and the experimental setup for Brown corpus is the
same as that in (Bengio et al., 2003), the first 800000 words (ca01?cj54) were used for
training, the following 200000 words (cj55?cm06) for validation and the rest (cn01?cr09)
for test.
Models n m nh Direct Bias PPL
FNNLM 5 100 200 No No 223.85
RNNLM - 100 200 No No 221.10
LSTM-RNNLM - 100 200 No No 237.93
LSTM-RNNLM - 100 200 Yes No 242.54
LSTM-RNNLM - 100 200 No Yes 237.18
Table 1: Camparative results of different neural network language models
The experiment results are showed in Table 1 which suggest that, on a small corpus
likes the Brown Corpus, RNNLM and LSTM-RNN did not show a remarkable advantage
over FNNLM, instead a bit higher perplexity was achieved by LSTM-RNNLM. Maybe
more data is needed to train RNNLM and LSTM-RNNLM because longer dependencies are
taken into account by RNNLM and LSTM-RNNLM when predicting next word. LSTM-
RNNLM with bias terms or direct connections was also evaluated here. When the direct
connections between input layer and output layer of LSTM-RNN are enabled, a slightly
higher perplexity but shorter training time were obtained. An explanation given for this
phenomenon by Bengio et al. (2003) is that direct connections provide a bit more capacity
and faster learning of the ”linear” part of mapping from inputs to outputs but impose a
negative effect on generalization. For bias terms, no significant improvement on performance
was gained by adding bias terms which was also observed on RNNLM by Mikolov (2012).
In the rest of this paper, all studies will be performed on LSTM-RNNLM with neither
6
A Study on Neural Network Language Modeling
direct connections nor bias terms, and the result of this model in Table 1 will be used as
the baseline for the rest studies.
3. Optimization Techniques
3.1 Importance Sampling
Inspired by the contrastive divergence model (Hinton, 2002), Bengio and Senecal (2003b)
proposed a sampling-based method to speed up the training of neural network language
models. In order to apply this method, the outputs of neural network should be normalized
in following way instead of using a softmax function:
P (vi|wt?11 ) =
e?y(vi,w
t?1
1 )?k
j=1 e
?y(vj ,wt?11 )
, i = 1, 2, . . . , k; t = 1, 2, . . . , T
then, neural network language models can be treated as a special case of energy-based
probability models.
The main idea of sampling based method is to approximate the average of log-likelihood
gradient with respect to the parameters ? by samples rather than computing the gradient
explicitly. The log-likelihood gradient for the parameters set ? can be generally represented
as the sum of two parts: positive reinforcement for target word wt and negative reinforce-
ment for all word vi, weighted by P (vi|wt?11 ):
?logP (wt|wt?11 )
??
= ??y(wt, w
t?1
1 )
??
+
k?
i=1
P (vi|wt?11 )
?y(vi, w
t?1
1 )
??
Three sampling approximation algorithms were presented by Bengio and Senecal (2003b):
Monte-Carlo Algorithm, Independent Metropolis-Hastings Algorithm and Importance Sam-
pling Algorithm. However, only importance sampling worked well with neural network lan-
guage model. In fact, 19-fold speed-up was achieved during training while no degradation of
the perplexities was observed on both training and test data (Bengio and Senecal, 2003b).
Importance sampling is a Monte-Carlo scheme using an existing proposal distribution,
and its estimator can be represented as:
E[
?
x?P
P (x)g(x)] =
1
N
?
x???
g(x
?
)
P (x
?
)
Q(x?)
where, Q is an existing proposal distribution, N is the number of samples from Q, ? is
the set of samples from Q. Appling importance sampling to the average log-likelihood
gradient of negative samples and the denominator of P (vi|wt?11 ), then the overall estimator
for example (wt, w
t?1
1 ) using N samples from distribution Q is:
E[
?logP (wt|wt?11 )
??
] = ??y(wt, w
t?1
1 )
??
+
?
w???
?y(w
? |wt?11 )
?? e
?y(w? ,wt?11 )/Q(w
? |wt?11 )?
w??? e
?y(w? ,wt?11 )/Q(w? |wt?11 )
7
D. Shi
Figure 3: Architecture of class based LSTM-RNNLM
In order to avoid divergence, the sample size N should be increased as training processes
which is measured by the effective sample size of importance sampling:
S =
(
?N
j=1 rj)
2?N
j=1 r
2
j
, rj ?
e?y(w
?
j ,w
t?1
1 )/Q(w
?
j |w
t?1
1 )?
w??? e
?y(w? ,wt?11 )/Q(w? |wt?11 )
At every iteration, sampling is done block by block with a constant size until the effective
sample size S becomes greater than a minimum value, and a full back-propagation will be
performed when the sampling size N is greater than a certain threshold.
The introduction of importance sampling is just posted here for completeness and no
further studies will be performed on it. Because a quick statistical language model which
is well trained, like n-gram based language model, is needed to implement importance
sampling. In addition, it cannot be applied into RNNLM or LSTM-RNNLM directly and
other simpler and more efficient speed-up techniques have been proposed now.
3.2 Word Classes
Before the idea of word classes was introduced to NNLM, it had been used in LM extensively
for improving perplexities or increasing speed (Brown et al., 1992; Goodman, 2001b). With
word classes, every word in vocabulary is assigned to a unique class, and the conditional
probability of a word given its history can be decomposed into the probability of the word’s
class given its history and the probability of the word given its class and history, this is:
P (wt|wt?11 ) = P (wt|c(wt), w
t?1
1 )P (c(wt)|w
t?1
1 )
where c(wt) is the class of word wt. The architecture of class based LSTM-RNNLM is
illustrated in Figure 3, and p, q are the lower and upper index of words in a class respectively.
Morin and Bengio (2005) extended word classes to a hierarchical binary clustering of
words and built a hierarchical neural network language model. In hierarchical neural net-
work language model, instead of assigning every word in vocabulary with a unique class,
a hierarchical binary tree of words is built according to the word similarity information
extracted from WordNet (Fellbaum, 1998), and every word in vocabulary is assigned with a
8
A Study on Neural Network Language Modeling
bit vector b = [b1(vi), b2(vi), . . . , bl(vi)], i = 1, 2, . . . , k. When b1(vi), b2(vi), . . . , bj?1(vi) are
given, bj(vi) = 0, j = 1, 2, . . . , l indicates that word vi belongs to the sub-group 0 of current
node and bj(vi) = 1 indicates it belongs to the other one. The conditional probability of
every word is represented as:
P (vi|wt?11 ) =
l?
j=1
P (bj(wt)|b1(wt), . . . , bj?1(wt), wt?11 )
Theoretically, an exponential speed-up, on the order of k/log2k, can be achieved with
this hierarchical architecture. In Morin and Bengio (2005), impressive speed-up during both
training and test, which were less than the theoretical one, were obtained but an obvious
increase in PPL was also observed. One possible explanation for this phenomenon is that
the introduction of hierarchical architecture or word classes impose negative influence on
the word classification by neural network language models. As is well known, a distribution
representation for words, which can be used to represent the similarities between words, is
formed by neural network language models during training. When words are clustered into
classes, the similarities between words from different classes cannot be recognized directly.
For a hierarchical clustering of words, words are clustered more finely which might lead to
worse performance, i.e., higher perplexity, and deeper the hierarchical architecture is, worse
the performance would be.
To explore this point further, hierarchical LSTM-NNLMs with different number of hi-
erarchical layers were built. In these hierarchical LSTM-NNLMs, words were clustered
randomly and uniformly instead of according to any word similarity information. The re-
sults of experiment on these models are showed in Table 2 which strongly support the
above hypothesis. When words are clustered into hierarchical word classes, the speed of
both training and test increase, but the effect of speed-up decreases and the performance
declines dramatically as the number of hierarchical layers increases. Lower perplexity can be
expected if some similarity information of words is used when clustering words into classes.
However, because of the ambiguity of words, the degradation of performance is unavoidable
by assigning every word with a unique class or path. On the other hand, the similarities
among words recognized by neural network is hard to defined, but it is sure that they are
not confined to linguistical ones.
Model m nh Method l PPL
Words/s
Train Test
LSTM-NNLM 100 200 Uniform 1 227.51 607.09 2798.97
LSTM-NNLM 100 200 Uniform 3 312.82 683.04 3704.28
LSTM-NNLM 100 200 Uniform 5 438.58 694.43 3520.27
LSTM-NNLM 100 200 Freq 1 248.99 600.56 2507.97
LSTM-NNLM 100 200 Sqrt-Freq 1 237.93 650.16 3057.27
Table 2: Results for class-based models
There is a simpler way to speed up neural network language models using word classes
which was proposed by Mikolov et al. (2011). Words in vocabulary are arranged in descent
9
D. Shi
order according to their frequencies in training data set, and are assigned to classes one by
one using following rule:
i
r
<
z?
j=1
fj
F
? i+ 1
r
, 0 ? i ? r ? 1
where, r is the target number of word classes, fj is the frequency of the j-th word in
vocabulary, the sum of all words’ frequencies F =
?k
j=1 fj . If the above rule is satisfied,
the z-th word in vocabulary will be assigned to i-th class. In this way, the word classes
are not uniform, and the first classes hold less words with high frequency and the last ones
contain more low-frequency words. This strategy was further optimized by (Mikolov, 2012)
using following criterion:
i
r
<
z?
j=1
?
fj/F
dF
? i+ 1
r
where, the sum of all words’ sqrt frequencies dF =
?k
j=1
?
fj/F .
The experiment results (Table 2) indicate that higher perplexity and a little more train-
ing time were obtained when the words in vocabulary were classified according to their
frequencies than classified randomly and uniformly. When words are clustered into word
classed using their frequency, words with high frequency, which contribute more to final
perplexity, are clustered into very small word classes, and this leads to higher perplexity.
On the other hand, word classes consist of words with low frequency are much bigger which
causes more training time. However, as the experiment results show, both perplexity and
training time were improved when words were classified according to their sqrt frequency,
because word classes were more uniform when built in this way. All other models in this
paper were speeded up using word classes, and words were clustered according to their sqrt
frequencies.
3.3 Caching
Like word classes, caching is also a common used optimization technique in LM. The cache
language models are based on the assumption that the word in recent history are more
likely to appear again. In cache language model, the conditional probability of a word
is calculated by interpolating the output of standard language model and the probability
evaluated by caching, like:
P (wt|wt?10 ) = ?Po(wt|w
t?1
0 ) + (1? ?)Pc(wt|w
t?1
0 )
where, Po(wt|wt?10 ) is the output of standard language model, Pc(wt|w
t?1
0 ) is the probability
evaluated using caching, and ? is a constant, 0 ? ? ? 1.
Soutner et al. (2012) combined FNNLM with cache model to enhance the performance
of FNNLM in speech recognition, and the cache model was formed based on the previous
context as following:
Pc(wt|wt?1t?N ) =
1
N
N?
j=1
??(wt, wt?j)
10
A Study on Neural Network Language Modeling
where, ?(·) means Kronecker delta, N is the cache length, i.e., the number of previous words
taken as cache, ? is a coefficient depends on j which is the distance between previous word
and target word. A cache model with forgetting can be obtained by lowering ? linearly
or exponentially respecting to j. A class cache model was also proposed by Soutner et al.
(2012) for the case in which words are clustered into word classes. In class cache model, the
probability of target word given the last recent word classes is determined. However, both
word based cache model and class one can be defined as a kind of unigram language model
built from previous context, and this caching technique is an approach to combine neural
network language model with a unigram model.
Another type of caching has been proposed as a speed-up technique for RNNLMs (Bengio
et al., 2001; Kombrink et al., 2011; Si et al., 2013; Huang et al., 2014). The main idea of this
approach is to store the outputs and states of language models for future prediction given
the same contextual history. In Huang et al. (2014), four caches were proposed, and they
were all achieved by hash lookup tables to store key and value pairs: probability P (wt|wt?10 )
and word sequence wt0; history w
t?1
0 and its corresponding hidden state vector; history w
t?1
0
and the denominator of the softmax function for classes; history wt?10 , class index c(wt) and
the denominator of the softmax function for words. In Huang et al. (2014), around 50-fold
speed-up was reported with this caching technique in speech recognition but, unfortunately,
it only works for prediction and cannot be applied during training.
Inspired by the first caching technique, if the previous context can be taken into account
through the internal states of RNN, the perplexity is expected to decrease. In this paper,
all language models are trained sentence by sentence, and the initial states of RNN are
initialized using a constant vector. This caching technique can be implemented by simply
initializing the initial states using the last states of direct previous sentence in the same
article. However, the experiment result (Table 3) shows this caching technique did not work
as excepted and the perplexity even increased slightly. Maybe, the Brown Corpus is too
small and more data is needed to evaluated this caching technique, as more context is taken
into account with this caching technique.
Models m nh Caching PPL
LSTM-NNLM 100 200 No 237.93
LSTM-NNLM 100 200 Yes 241.45
Table 3: Results of Cached LSTM-RNNLM
3.4 Bidirectional Recurrent Neural Network
In Sutskever et al. (2014), significant improvement on neural machine translation (NMT)
for an English to French translation task was achieved by reversing the order of input word
sequence, and the possible explanation given for this phenomenon was that smaller ”minimal
time lag” was obtained in this way. In my opinion, another possible explanation is that a
word in word sequence may more statistically depend on the following context than previous
one. After all, a number of words are determined by its following words instead of previous
ones in some natural languages. Take the articles in English as examples, indefinite article
11
D. Shi
Figure 4: Encode word sequence using bidirectional recurrent neural network
”an” is used when the first syllable of next word is a vowel while ”a” is preposed before
words starting with consonant. What’s more, if a noun is qualified by an attributive clause,
definite article ”the” should be used before the noun. These examples illustrate that words
in a word sequence depends on their following words sometimes. To verify this hypothesis
further, an experiment is performed here in which the word order of every input sentence
is reversed, and the probability of word sequence w1w2. . .wT is evaluated as following:
P (wT1 ) =
T?
t=1
P (wt|wTt+1)
However, the experiment result (Table 4) shows that almost the same perplexity was
achieved by reversing the order of words. This indicates that the same amount statistical
information, but not exactly the same statistical information, for a word in a word sequence
can be obtained from its following context as from its previous context, at least for English.
Model m nh Reverse PPL
LSTM-NNLM 100 200 No 237.93
LSTM-NNLM 100 200 Yes 240.48
Table 4: Reverse the order of word sequence
As a word in word sequence statistically depends on its both previous and following
context, it is better to predict a word using context from its both side. Bidirectional recur-
rent neural network (BiRNN) (Schuster and Paliwal, 1997) was designed to process data
in both directions with two separate hidden layers, so better performance can be expected
by using BiRNN. BiRNN was introduced to speech recognition by Graves et al. (2013b),
and then was evaluated in other NLP tasks, like NMT (Bahdanau et al., 2015; Wu et al.,
2016). In these studies, BiRNN showed more excellent performance than unidirectional
12
A Study on Neural Network Language Modeling
Figure 5: A possible scheme for the architecture of ANN
RNN. Nevertheless, BiRNN cannot be evaluated in LM directly as unidirectional RNN,
because statistical language modeling is based on the chain rule which assumes that word
in a word sequence only statistically depends on one side context. BiRNN can be applied
in NLP tasks, like speech recognition and machine translation, because the input word se-
quences in these tasks are treated as a whole and usually encoded as a single vector. The
architecture for encoding input word sequences using BiRNN is showed in Figure 4. The
facts that better performance can be achieved using BiRNN in speech recognition or ma-
chine translation indicate that a word in a word sequence is statistically determined by the
words of its both side, and it is not a suitable way to deal with word sequence in a natural
language word by word in an order.
4. Limits of Neural Network Language Modeling
NNLM is state of the art, and has been introduced as a promising approach to various NLP
tasks. Numerous researchers from different areas of NLP attempt to improve NNLM, ex-
pecting to get better performance in their areas, like lower perplexity on test data, less word
error rate (WER) in speech recognition, higher Bilingual Evaluation Understudy (BLEU)
score in machine translation and etc. However, few of them spares attention on the limits
of NNLM. Without a thorough understanding of NNLM’s limits, the applicable scope of
NNLM and directions for improving NNLM in different NLP tasks cannot be defined clearly.
In this section, the limits of NNLM will be studied from two aspects: model architecture
and knowledge representation.
4.1 Model Architecture
In most language models including neural network language models, words are predicated
one by one according to their previous context or following one which is believed to simulate
the way human deal with natural languages, and, according to common sense, human
actually speak or write word by word in a certain order. However, the intrinsic mechanism
in human mind of processing natural languages cannot like this way. As mentioned above, it
is not always true that words in a word sequence only depend on their previous or following
context. In fact, before human speaking or writing, they know what they want to express
and map their ideas into word sequence, and the word sequence is already cached in memory
13
D. Shi
when human speaking or writing. In most case, the cached word sequence may be not a
complete sentence but at least most part of it. On the other hand, for reading or listening,
it is better to know both side context of a word when predicting the meaning of the word
or define the grammar properties of the word. Therefore, it is not a good strategy to deal
with word sequences in a natural language word by word in a certain order which has also
been questioned by the success application of BiRNN in some NLP tasks.
Another limit of NNLM caused by model architecture is original from the monotonous
architecture of ANN. In ANN, models are trained by updating weight matrixes and vectors
which distribute among all nodes. Training will become much more difficult or even un-
feasible when increasing the size of model or the variety of connections among nodes, but
it is a much efficient way to enhance the performance of ANN. As is well known, ANN is
designed by imitating biological neural system, but biological neural system does not share
the same limit with ANN. In fact, the strong power of biological neural system is original
from the enormous number of neurons and various connections among neurons, including
gathering, scattering, lateral and recurrent connections (Nicholls et al., 2011). In biological
neural system, the features of signals are detected by different receptors, and encoded by
low-level central neural system (CNS) which is changeless. The encoded signals are inte-
grated by high-level CNS. Inspired by this, an improvement scheme for the architecture of
ANN is proposed, as illustrated in Figure 5. The features of signal are extracted accord-
ing to the knowledge in certain field, and every feature is encoded using changeless neural
network with careful designed structure. Then, the encoded features are integrated using a
trainable neural network which may share the same architecture as existing ones. Because
the model for encoding does not need to be trained, the size of this model can be much
huge and the structure can be very complexity. If all the parameters of encoding model
are designed using binary, it is possible to implement this model using hardware and higher
efficiency can be expected.
Model m nh
Training Data PPL
Electronics Books Electronics Books
LSTM-NNLM 100 200 Yes No 146.62 353.16
LSTM-NNLM 100 200 No Yes 280.91 246.35
LSTM-NNLM 100 200 Yes Yes 147.28 302.92
Table 5: Evaluating NNLM on data sets from different fields
4.2 Knowledge Representation
The word ”learn” appears frequently with NNLM, but what neural network language models
learn from training data set is rarely analyzed carefully. The common statement about the
knowledge learned by neural network language models is the probabilistic distribution of
word sequences in a natural language. Strictly speaking, it is the probabilistic distribution
of word sequences from a certain training data set in a natural language, rather than the
general one. Hence, the neural network language model trained on data set from a certain
field will perform well on data set from the same field, and neural network language model
14
A Study on Neural Network Language Modeling
trained on a general data set may show worse performance when tested on data set from a
special field. In order to verify this, one million words reviews on electronics and books were
extracted from Amazon reviews (He and J.Mcauley, 2016; Mcauley et al., 2015) respectively
as data sets from different fields, and 800000 words for training, 100000 words for validation,
and the rest for test. In this experiment, two models were trained on training data from
electronics reviews and books reviews respectively, and the other one was trained on both.
Then, all three models were tested on the two test data sets.
The lowest perplexity on each test data set was gained by the model trained on corre-
sponding training data set, instead of the model trained on both training data set (Table
6). The results show that the knowledge represented by a neural network language model
is the probabilistic distribution of word sequences from training data set which varies from
field to field. Except for the probabilistic distribution of word sequences, the feature vec-
tors of words in vocabulary are also formed by neural network during training. Because
of the classification function of neural network, the similarities between words can be ob-
served using these feature vectors. However, the similarities between words are evaluated
in a multiple dimensional space by feature vectors and it is hard to know which features of
words are taken into account when these vectors are formed, which means words cannot be
grouped according to any single feature by the feature vectors. In summary, the knowledge
represented by neural network language model is the probabilistic distribution of word se-
quences from certain training data set and feature vectors for words in vocabulary formed
in multiple dimensional space. Neither the knowledge of language itself, like grammar, nor
the knowledge conveyed by a language can be gained from neural network language mod-
els. Therefore, NNLM can be a good choice for NLP tasks in some special fields where
language understanding is not necessary. Language understanding cannot be achieved just
with the probabilistic distribution of word sequences in a natural language, and new kind
of knowledge representation should be raised for language understanding.
Since the training of neural network language model is really expensive, it is important
for a well-trained neural network language model to keep learning during test or be improved
on other training data set separately. However, the neural network language models built
so far do not show this capacity. Lower perplexity can be obtained when the parameters
of a trained neural network language model are tuned dynamically during test, as showed
in Table 5, but this does not mean neural network language model can learn dynamically
during test. ANN is just a numerical approximation method in nature, and it approximate
the target function, the probabilistic distribution of word sequences for LM, by tuning
parameters when trained on data set. The learned knowledge is saved as weight matrixes
and vectors. When a trained neural network language model is expected to adaptive to new
data set, it should be retrained on both previous training data set and new one. This is
another limit of NNLM because of knowledge representation, i.e., neural network language
models cannot learn dynamically from new data set.
5. Future Work
Various architectures of neural network language models are described and a number of
improvement techniques are evaluated in this paper, but there are still something more
should be included, like gate recurrent unit (GRU) RNNLM, dropout strategy for address-
15
D. Shi
ing overfitting, character level neural network language model and ect. In addition, the
experiments in this paper are all performed on Brown Corpus which is a small corpus, and
different results may be obtained when the size of corpus becomes larger. Therefore, all the
experiments in this paper should be repeated on a much larger corpus.
Several limits of NNLM has been explored, and, in order to achieve language under-
standing, these limits must be overcome. I have not come up with a complete solution
yet but some ideas which will be explored further next. First, the architecture showed in
Figure 5 can be used as a general improvement scheme for ANN, and I will try to figure
out the structure of changeless neural network for encoder. What’s more, word sequences
are commonly taken as signals for LM, and it is easy to take linguistical properties of
words or sentences as the features of signals. However, it maybe not a proper way to deal
with natural languages. Natural languages are not natural but man-made, and linguistical
knowledge are also created by human long after natural language appeared. Liguistical
knowledge only covers the ”right” word sequences in a natural language, but it is common
to deal with ”wrong” ones in real world. In nature, every natural language is a mechanism
of linking voices or signs with objects, both concrete and abstract. Therefore, the proper
way to deal with natural languages is to find the relations between special voices or signs
and objects, and the features of voices or signs can be defined easier than a natural language
itself. Every voice or sign can be encoded as a unique code, vector or matrix, according to
its features, and the similarities among voices or signs are indeed can be recognized from
their codes. It is really difficult to model the relation between voices or signs and objects
at once, and this work should be split into several steps. The first step is to covert voice or
sign into characters, i.e., speech recognition or image recognition, but it is achieved using
the architecture described in Figure 5.
6. Conclusion
In this paper, different architectures of neural network language models were described,
and the results of comparative experiment suggest RNNLM and LSTM-RNNLM do not
show any advantages over FNNLM on small corpus. The improvements over these models,
including importance sampling, word classes, caching and BiRNN, were also introduced and
evaluated separately, and some interesting findings were proposed which can help us have
a better understanding of NNLM.
Another significant contribution in this paper is the exploration on the limits of NNLM
from the aspects of model architecture and knowledge representation. Although state of
the art performance has been achieved using NNLM in various NLP tasks, the power of
NNLM has been exaggerated all the time. The main idea of NNLM is to approximate the
Model m nh Dynamic PPL
LSTM-NNLM 100 200 No 237.93
LSTM-NNLM 100 200 Yes 174.57
Table 6: Examine the learning ability of neural network
16
A Study on Neural Network Language Modeling
probabilistic distribution of word sequences in a natural language using ANN. NNLM can
be successfully applied in some NLP tasks where the goal is to map input sequences into
output sequences, like speech recognition, machine translation, tagging and ect. However,
language understanding is another story. For language understanding, word sequences must
be linked with any concrete or abstract objects in real world which cannot be achieved just
with this probabilistic distribution.
All nodes of neural network in a neural network language model have parameters needed
to be tunning during training, so the training of the model will become very difficult or
even impossible if the model’s size is too large. However, an efficient way to enhance the
performance of a neural network language model is to increase the size of model. One
possible way to address this problem is to implement special functions, like encoding, using
changeless neural network with special struture. Not only the size of the changeless neural
network can be very large, but also the structure can be very complexity. The performance
of NNLM, both perplexity and training time, is expected to be improved dramatically in
this way.
17
D. Shi
References
D. Bahdanau, K. Cho, and Y. Bengio. Neural machine translation by jointly learning to
align and translate. In International Conference on Learning Representations, 2015.
Y. Bengio and J. S. Senecal. Quick training of probabilistic neural nets by importance
sampling. In AISTATS, 2003b.
Y. Bengio, R. Ducharme, and P. Vincent. A neural probabilistic language model. In
Advances in Neural Information Processing Systems, volume 13, pages 933–938, 2001.
Y. Bengio, R. Ducharme, P. Vincent, and C. Jauvin. A neural probabilistic language model.
Journal of Machine Learning Research, 3(Feb):1137–1155, 2003.
P. F. Brown, V. J. D. Pietra, P. V. DeSouza, J. C. Lai, and R. L. Mercer. Class-based
n-gram models of natural language. Computational Linguistics, 18:467–479, 1992.
M. J. Castro and F. Prat. New directions in connectionist language modeling. In Lecture
Notes in Computer Science, pages 1137–1155, 2003.
K. Cho, B. V. Merrienboer, C. Gulcehre, D. Bahdanau, F. Bougares, H. Schwenk, and
Y. Bengio. Learning phrase representations using rnn encoder-decoder for statistical
machine translation. Computer Science, 15(4):403–434, 2014a.
K. Cho, B. M. Van, C. Gulcehre, D. Bahdanau, F. Bougares, H. Schwenk, and Y. Ben-
gio. Learning phrase representations using rnn encoder-decoder for statistical machine
translation. arXiv preprint arXiv:1406.1078, 2014b.
R. Collobert and J. Weston. Fast semantic extraction using a novel neural network archi-
tecture. In Proceedings of the Meeting of the Association for Computational Linguistics,
volume 45, pages 560–567, 2007.
R. Collobert and J. Weston. A unified architecture for natural language processing - deep
neural networks with multitask learning. In Proceedings of the 25th International Con-
ference on Machine Learning, pages 160–167, 2008.
C. Fellbaum. WordNet: An Electronic Lexical Database. MIT Press, 1998.
F. A. Gers and J. Schmidhuber. Recurrent nets that time and count. In Proceedings of the
IEEE-INNS-ENNS International Joint Conference on, volume 3, pages 189–194, 2000.
J. Goodman. Classes for fast maximum entropy training. In International Conference on
Acoustics, Speech and Signal Processing (ICASSP), volume 1, pages 561–564, 2001b.
J. D. Goodman. A bit of progress in language modeling. Computer Speech and Langauge,
15(4):403–434, 2001a.
A. Graves, A. r. Mohamed, and G. Hinton. Speech recognition with deep recurrent neu-
ral networks. In 2013 IEEE International Conference on Acoustics, Speech and Signal
Processing (ICASSP), pages 6645–6649, 2013a.
18
A Study on Neural Network Language Modeling
A. Graves, N. Jaitly, and A. R. Mohamed. Hybrid speech recognition with deep bidirec-
tional lstm. In Automatic Speech Recognition and Understanding (ASRU), pages 273–278,
2013b.
R. He and J.Mcauley. Ups and downs: modeling the visual evolution of fashion trends with
one-class collaborative filtering. In International World Wide Web Conferences Steering
Committee, 2016.
G. Hinton. Training products of experts by minimizing contrastive divergence. Neural
Computation, 14(8):1771–1800, 2002.
G. Hinton, L. Deng, D. Yu, G. E. Dahl, A. r. Mohamed, N. Jaitly, A. Senior, V. Vanhoucke,
P. Nguyen, T. N. Sainath, and B. Kingsbury. Deep neural networks for acoustic modeling
in speech recognition: The shared views of four research groups. IEEE Signal Processing
Magazine, 29(6):82–97, 2012.
S. Hochreiter and J. Schmidhuber. Long short-term memory. Neural Computation, 9(8):
1735–1780, 1997.
Z. Huang, G. Zweig, and B. Dumoulin. Cache based recurrent neural network language
model inference for first pass speech recognition. In Acoustics, Speech and Signal Pro-
cessing (ICASSP), 2014 IEEE International Conference on, pages 6354–6358, 2014.
R. Jozefowicz, O. Vinyals, M. Schuster, N. Shazeer, and Y. Wu. Exploring the limits of
language modeling. Neural Computation, 3(2):246–257, 2016.
S. Kombrink, T. Mikolov, M. Karafiat, and L. Burget. Recurrent neural network based
language modeling in meeting recognization. In INTERSPEECH, 2011.
J. Mcauley, C. Targett, Q. Shi, and A. V. D. Hengel. Image-based recommendations on styles
and substitutes. In International ACM SIGIR Conference on Research and Development
in Information Retrieval, 2015.
R. Miikkulainen and M. G. Dyer. Natural language processing with modular pdp neural
networks and distributed lexicon. Cognitive Science, 15(3):343–399, 1991.
T. Mikolov. Statistical language models based on neural networks. PhD thesis, Brno Uni-
versity of Technology, 2012.
T. Mikolov, M. Karafiat, L. Burget, J. H. Cernocky, and S. Khudanpur. Recurrent neural
network based language model. In Interspeech, volume 2, pages 1045–1048, 2010.
T. Mikolov, S. Kombrink, J. H. Cernocky, and S. Khudanpur. Extensions of recurrent
neural network based language model. In IEEE International Conference on Acoustics,
Speech, and Signal Processing (ICASSP), pages 5528–5531, 2011.
F. Morin and Y. Bengio. Hierarchical probabilistic neural network language model. In
Aistats, volume 5, pages 246–252, 2005.
J. G. Nicholls, A. R. Martin, P. A. Brown, M. E. Diamond, and D. A. Weisblat. From
neuron to brain. Sinauer Associates, Inc, 5th edition, 2011.
19
D. Shi
D. E. Rumelhart, G. E. Hinton, and R. J. Williams. Learning internal representations by
back-propagating errors. Nature, 323:533–536, 1986.
J. Schmidhuber. Sequential neural neural text compression. IEEE Transactions on Neural
Network, 7(1):142–146, 1996.
M. Schuster and K. K. Paliwal. Bidirectional recurrent neural networks. Signal Processing,
IEEE Transactions on, 45(11):2673–2681, 1997.
Y. Si, Q. Zhang, T. Li, J. Pan, and Y. Yan. Prefix tree based n-best list rescoring for
recurrent neural network language model used in speech recognition system. In INTER-
SPEECH, 2013.
D. Soutner, Z. Loose, L. Muller, and A. Prazak. Neural network language model with cache.
In International Conference on Text, Speech and Dialogue, pages 528–534, 2012.
M. Sundermeyer, R. Schluter, and H. Ney. Lstm nerual networks for language modeling.
In Interspeech, pages 194–197, 2012.
M. Sundermeyer, I. Oparin, J. L. Gauvain, B. Freiberg, R. Schluter, and H. Ney. Comparison
of feedforward and recurrent nerual network language models. In Acoustics, Speech and
Signal Processing (ICASSP), 2013 IEEE International Conference on, pages 8430–8434,
2013.
I. Sutskever, O. Vinyals, and Q. Le. Sequence to sequence learning with neural networks. In
Advances in Neural Information Processing Systems, volume 4, pages 3104–3112, 2014.
Y. Wu, M. Schuster, Z. Chen, Q. V. Le, M. Norouzi, W. Macherey, M. Krikun, Y. Cao,
Q. Gao, and K. Macherey. Google’s neural machine translation system: bridging the gap
between human and machine translation. Computer Science, 15(4):403–434, 2016.
W. Xu and A. Rudnicky. Can artificial neural network learn language models. In Proceedings
of International Conference on Speech and Language Processing, pages 202–205, 2000.
20
