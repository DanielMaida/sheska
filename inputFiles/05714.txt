A Stronger Foundation for Computer Science and P=NP
Mark Inman, Ph.D.
mark.inman@egs.edu
August 14, 2017
Abstract
This article constructs a Turing Machine which can solve for ?
?
which is RE-
complete. Such a machine is only possible if there is something wrong with the foun-
dations of computer science and mathematics. We therefore check our work by looking
very closely at Cantor’s diagonalization and construct a novel formal language as an
Abelian group which allows us, through equivalence relations, to provide a non-trivial
counterexample to Cantor’s argument. As if that wasn’t enough, we then discover that
the impredicative nature of Go?del’s diagonalization lemma leads to logical tautology,
invalidating any meaning behind the method, leaving no doubt that diagonalization is
flawed. Our discovery in regards to these foundational arguments opens the door to
solving the P vs NP problem.
1 Turing’s Proof on the Entscheidungsproblem has
a Fatal Flaw
1.1 Overview
1.1.1 Context
Turing’s monumental 1936 paper set the mechanistic description of computation which
directly lead to the development of programmable computers. His motivation was
the logic problem known as the Entscheidungsproblem, which asks if there exists an
algorithm which can determine if any input of first order logic is valid or invalid. After
defining automated computing, he described a program called an H Machine which
can validate or invalidate its inputs based on reading a description number of that
program. However, he did not provide an actual construction of such a machine, he
only presumed its possibility to exist. His proof then depended upon this H Machine
not being able to validate itself. He gives a detailed description as to why it can not
validate itself.
However, a close reading of his paper shows an added assumption by Turing when he
constructs his H Machine. While this assumption does not effect the construction or
effectiveness of a Universal Turing Machine, it does have an effect on the overall results
1
ar
X
iv
:1
70
8.
05
71
4v
1 
 [
cs
.C
C
] 
 1
8 
A
ug
 2
01
7
regarding the Halting problem and its sister problem, the Entscheidungsproblem, as
well as any related results having to do with computational complexity.
The significance of this discovery of a fatal assumption in Turing’s work, should
not be taken lightly. It effects more than just the proof on the Entscheidungsproblem,
which should remain open after this discovery, but it also effects existing, accepted
results on computability and the very foundations of key concepts in computer science
such as complexity. This means we must write new textbooks.
In this article, we point out Turing’s assumption and then construct a description
of a machine which does exactly what the assumption assumes is impossible. Because
we have found an erroneous assumption, we must disregard Turing’s final results and
any results which are derived from his method, including the Space Hierarchy Theorem
which derives from Turing’s method using the same kind of assumption.
The construction of such a machine may have application in fault-tolerance of
run-time self-correcting code validation in artificial intelligence implementations. It
may also lead to better understanding of complexity relationships between complexity
classes, as several results will have to be modified in response.
Furthermore, in a following section, we review methods which are differently con-
structed than Turing’s method, but are considered to be reducible to Turing’s method,
such as Cantor’s Diagonalization Argument (CDA), and also Go?del’s Diagonalization
Lemma (GDL). By addressing all three methods for proof in one article, we have ef-
fectively deconstructed the current foundations in computer science when it comes to
the limits of computability. If we only deconstructed one method, then there might be
reason to ignore our results on the foundation that it does not agree with the other
two methods. However, we can and will address all three, and invalidate them all by
providing non-trivial counter examples to the false assumptions in the methods.
1.1.2 Preliminary Considerations
The terms Circular Machine and Circle-free Machine are suitable for our description
and we will use Turing’s own definition of a computing machine. It is convenient to
note here that a Circular Machine is deemed by Turing to be unsatisfactory due to
forever looping, redundantly over a repeating pattern. Also, a Circle-free Machine
is deemed by Turing to be satisfactory because of its ability to continue deciding
indefinitely, without entering an infinite loop. We have chosen to keep Turing’s original
terminology for the sake of clarity when comparing the work of this article to that of
Turing’s original paper. Also, we choose his terminology because Turing’s description
of the Halting problem is completely mechanical, while many modern descriptions
rely on an oracle, Cantor’s Diagonalization or logic similar to Go?del’s Diagonalization
Lemma. Turing’s description is independent from these reductions in significant ways
as a mechanical process. This helps the reader directly compare this article with the
original proof without intermediary interpretations or simplifications. [7]
A Standard Description or S.D. is the rule set for any given Turing Machine M
in a standard form. By creating a standard, the rule sets themselves can be used
to create a Description Number or D.N. which itself may be readable by a Universal
Turing Machine, U , as an instruction set. [7]
From Turing’s paper:
2
“Let D be the Turing Machine which when supplied with the Standard Description
(S.D.) of any computing machine M will test this S.D. and if M is circular will mark the
S.D. with the symbol ‘u’ and if it is circle free, will mark it with ‘s’ for ‘unsatisfactory’
and ‘satisfactory’ respectively. By combining machines D and U , we could construct
a machine H to compute the sequence of ?
?
” [7]
1.1.3 Turing’s Claim
Turing claims that while H is circle free by construction, when H is given the de-
scription number for H , it becomes circular. [7] In the eighth section of Turing’s paper
on the Entscheidungsproblem, Turing claims that ?
?
can not be determined because of
the following reason:
“The instructions for calculating the R(K)-th [figure] would amount to ‘calculate
the first R(K)-th figures computed by H and write down the R(K)-th’. This R(K)-th
would never be found. I.e. H is circular...” [7]
This is because, since H relies on certain subroutines to make its determination,
when it reaches and tries to evaluate K, it must call itself, which provides instructions
on reading inputs from 1 to K-1 in order to call the R(K)-th figure, but it can never
get there, because it keeps repeating its own instruction loop. [7]
1.1.4 Turing’s False Assumption
Turing assumed that there is no program that exists which can recognize itself arbitrar-
ily and move to a circle free state upon this recognition. He assumed that any program
would have to be programmed in such a way that when it reads itself, and calls its own
instructions, it must be circular when trying to determine if it is circular or not, as
described in the previous subsection. However, this is not necessarily the case and if
we can provide an example of a program which does recognize itself arbitrarily so that
it can switch to a circle-free state, then we’ve discovered a means to write H machine
in such a way that it may solve for ?
?
.
The question is, then, is there a Turing Machine which can recognize itself arbitrar-
ily1 when it reaches its own Description Number (D.N.), such that some H machine
configuration prints ?
?
?
We will, in the next subsection, construct a Supermachine that can recognize itself
as its own input which is then instructed to change to a circle free state upon this
recognition. Because such a construction exists, and because it is arbitrary for any
construction of this class of Turing Machines, we may solve for ?
?
non-trivially.
1by recognizing itself arbitrarily, we mean that it can recognize its own program or description number
even if K is not fixed. Also, there may not exist an initializer that feeds a fixed K to be recognized by a
single read instruction that skips K and just rubber stamps approval. Such “rubber stamping” is considered
a trivial case and is not of concern to this article.
3
1.2 The Existence of Self-validating Computers
1.2.1 Supermachine
Let us consider that H
?
is a controller machine with a D.N. of K
?
. It controls two
different H machines: H0 and H1. H0 and H1 each have the ability to determine
“u” or “s” on a D.N. input, except H0 tests as Turing describes, from D.N. 1 counting
upwards (Each D.N. is a natural number) and H1 tests from a certain twos complement
of whatever number is being tested by H0 as a simultaneous parallel input, such that
its subsequent D.N. is one less than the previously tested D.N. Let us represent each
D.N. by some integer i. H0 and H1 have a unique D.N. of K0 or K1 respectively.2
Upon input of i0 to be read by H0, let H
?
store the value pair (i0, z) until i0 is
determined to be satisfactory or unsatisfactory. When the output is determined, let
H
?
replace the (i0, z) with the respective (i0, s) or (i0, u) in the data store, such that
there is no longer a data store of (i0, z). Let the same process occur for i1, such that
H
?
also initially stores each D.N. input with (i1, z) and H1 reads i1 to determine
satisfactory or unsatisfactory, subsequently replacing the initial value pair with the
respective value pair (i1, s) or (i1, u) depending on the output of H1. A redundancy
occurs when some i0 = i1.
Let H
?
have the ability to compare value pairs such that the machine may recognize
a redundancy when it occurs, and may also recognize when a value pair contains a z
value on the condition of such a redundancy. Let’s call this a z-check ability.
Let Hs be the supermachine that is the configuration of all three H Machines as
described above and let Ks be the D.N. for the supermachine.
Initialize the identifier strings such that K1 < K0.
Let the number of bits in K0 = n. Let the twos complement of the first D.N. in-
put to H0 , which is 1, be determined by n such that it satisfies the equation c = 2n?1.
Lemma. Hs proceeds circle free, until it reads Ks. If c ?K0 > K1, then re-initialize
the D.N.3 in either K0 or K1 such that c ?K0 < K1. This guarantees that H0 will
read K1 before H1 reads K1 and also guarantees H1 will read K0 before H0 reads
K0. Let the controller H
?
contain a memory command which stores the decision value
pairs of H0 and H1. The controller may routinely check for a redundancy on the next
input.
Now consider when H0 reads K1, and K1 calls the D.N. for H0: H0 will call H1,
which will call H0 which will result in a z-check, recognizing that the value pair (K0,
z) is already stored in memory, and therefore, since K0 < c, we know that K0 is the
description number for itself, which is impossible to call by construction without calling
H1 first, which means it must be checking the description number for a machine which
calls itself, namely H1, which allows us to correctly store the value pair (K1, s). This
same reasoning can be applied for when H1 reads K0, correctly storing the value pair
(K0, s).
2This can be determined through a unique identifier string, which does not effect The machine’s function
or performance, but differentiates the two machines from each other giving them each a unique D.N.
3one may re-initialize, if necessary, the D.N. by adding irrelevant description information into some S.D.
yielding a different D.N. provided such information does not affect the integrity of the original S.D.
4
If however, the machine has determined a redundancy occurred on a value pair
where the value is either (i, s) or (i, u) (i.e., a negative evaluation on the z-check, but
the redundancy check is positive), then we have already evaluated this D.N. from the
other H machine at the top level, and we no longer have to continue within the range
1 to c, since they will all have been decided. The supermachine, at this point proceeds
to utilize machine H0 and proceeds from D.N. input value c+1, and continues through
the rest of all Description Numbers, c+ 2, c+ 3, etc... at least until it reaches its own
D.N., Ks, for no other D.N. should be problematic in determining the output decision.
Thus, Hs proceeds circle free, at least until it reaches Ks which is easily constructed
to be larger than c. 
1.2.2 ?
?
is Decidable
Proof. ?
?
is Decidable. At the point K
?
is received as an input, it is determined
satisfactory by either H0 or H1. Neither H0 nor H1 are called during this phase of
the process.
By lemma, K0 is decided by H1, K1 is decided by H0 and Hs continues indefinitely
until we reach Ks, which describes Hs. Ks is read by H
?
and as before, its Description
Number is stored along with its temporary pair value of z until H0 or H1 returns a
value for ?
?
at that location. Ks is sent to be verified by H0, which when H
?
calls Ks
for a second time, under the given recursive property of Ks which will eventually call
itself, the z-check for value pair (Ks, z) is recognized as both redundant and with a z
value, stored by H
?
in the data store, but because the associated value is z, the z-check
ability tells us this process has already occurred, sends Ks to H1, which self-verifies
repeated z-check values. By construction, the only value Ki which can provide this
multiple z-check values where Ki > c is Ks, so Hs now self-verifies the input Ks as its
own D.N., provides a value of “s” for satisfactory, and changes state to evaluate Ks +1
to continue indefinitely as a Circle-free Turing Machine.
Therefore, given some Universal Turing Machine which can emulate the Hs Ma-
chine, ?
?
is decidable over the set of all Description Numbers. y
1.3 Consequences
Solving for ?
?
is RE-complete. If Turing were correct, it would be impossible to solve
for this output. Since we have solved for ?
?
, we must consider the possibility that
there is a problem with our configuration which makes it impossible, or that there is
something fundamentally incorrect with our current foundations of mathematics.
For this reason, we continue in the next section to examine Cantor’s Diagonal Ar-
gument, of which Turing’s method is equivalent, as they can reduce the same results
to each other. If there is nothing fundamentally wrong with the foundations of math-
ematics and computer science, we should expect that any counter examples to CDA
will not exist, or will be trivial. However, if we can find counterexamples for arbitrary
5
Figure 1: A supermachine configuration appears to exist
6
solutions, then such solutions will not be trivial and will reinforce the findings of this
first section on the Entscheidungsproblem.
2 A Non-Trivial Counterexample to Cantor’s Diag-
onalization Argument
2.1 Overview
2.1.1 Method and Foundations
Conventional thought on CDA is that we would need an entirely new axiom schema to
find a counterexample to the method [2]. However, no new axioms are needed in this
article to find a counterexample to CDA. We present in this section, a new grammar
to generate a formal language for representation of an ?-regular language through
accepted foundations in set theory and the principles of formal languages.
For logical consistency, in order to examine CDA, we can not assume outright
that CDA is a method which produces theorems, nor can we rely on any theorems
derived from CDA or those theorems that reduce to it. This includes Turing’s proof
on the Entscheidungsproblem, as discussed in a pervious section, in our exploration of
it, as well as the downward Lowenheim-Skolem Theorem, or complexity results which
rely on diagonalization such as the Space Hierarchy Theorem, et al. We must also
exclude consequences of Cantor’s First Proof of Uncountability (CFPU) because of
its similarity to the method of CDA. This requires that we assume the cardinality
of the Real numbers as it relates to the Natural numbers is unknown, since CDA and
CFPU are the very foundation that prove the Reals are strictly larger than the Natural
numbers. This is for logical consistency only, our proof does not directly concern us
with the cardinality of the Real numbers. We are currently only concerned with the
foundations that lead to these prior results, and the counterexamples which call them
into sincere question.
We will re-explore CDA by creating an Abelian group which can be used as a
representation of an ?-regular language, and its set of well formed strings, explore this
representation’s properties and expressive power as a language, and create a class of
constructions of CDA which lead to non-trivial counterexamples to CDA. The resulting
counterexamples to CDA are found through a transformation of equivalent statements
over the construction.
2.2 Representing an ?-language by a Recursively Enumerable
Language
2.2.1 Notation and Preliminaries
Definition Let the Natural numbers be denoted by N.
Definition Let ? be the rank of N, from the Von Neumann Hierarchy.
Definition Let ?0 be the cardinality of N and the cardinality of any set bijective to
N.
7
Definition An ?-expansion is an unbounded expansion of symbols on a string Lim??,
and is denoted, for some symbol, z, as z? such that the cardinality of the set of the
number of symbols represented by the ?-expansion z? is ?0.
Definition An iteration of symbols has gone through ?-completion when an un-
bounded set of recursions of symbols in a string has a symbol or the empty string,
at the rank of the set of iterations.
Definition Let exhaustion be a necessary change in output of a recursion after ?-
completion of such recursion of symbols, where s at exhaustion is the symbol at the
rank of the unbounded iteration and s 6= i when i is the first symbol of the set of
symbols in the recursion.
For example, let x be defined as an infinite word having both 0 and 1’s written on
an infinite tape, however, we know that the starting symbol is 1, and there are an ?
number of 1s on the tape prior to any 0 appearing. We can prove by exhaustion that
the ?th symbol of the infinite word is 0, since ? is the rank of the total number of 1s
on the infinite tape and the symbol must change necessarily at that point, as we know
the word contains a 0.
Definition Let a special order of some set S be some ordering of S such that we
may determine the value of any distinct element of S by some operation on S which
guarantees the result is in S; i.e. an order which is arbitrary under closure.
Definition Let
?
be a set of terminal symbols which is its alphabet.
Definition Let V be a set of non-terminal starting symbols and R be a set of rules,
each in the form xAx?? xw for some strings w ?
?
, x ? V
? ?
when A ? V.
Definition Let
?
be an alphabet with at least 6 elements and the empty string .
Definition Let
??
1 be the set of all strings over
?
which includes all ? length strings.
Definition Let
??
2 be the set of strings which also include strings of length ? over a
subset
?
2 of at least two elements in
?
.
Definition Let
??
3 be the subset of
??
2 which are only the recursive, countably
infinite length strings over
?
2 so that the set of all symbols in each string has a
cardinality ?0.
Definition A language of the class of computable transfinite number T has a subset
of unique finite length strings
??
4 of
??
1 that is either bijective or surjective (but not
injective) to the set
??
3 .
Definition The alphabet
?
4 must also have a subset of at least three elements not a
member of
?
2 with at least one of these symbols to distinguish context between other
symbols of value.
Remark Note that the total cardinality of the set of strings in
??
3 is ?20 and fully
representable by an
??
4 mapping via Cantor pairing between the sets.
Definition Let
??
2 be the set of finite length strings over
?
2. For any language L in
the class T, the set of strings
??
over L,
??
=
??
4
? ??
2.
2.2.2 A Grammar for a Language in T
Chomsky, Backus and Naur laid the foundation for work in generative grammars and
our understanding of computer syntax with Backus-Naur form and the Chomsky hier-
archy among other means of representing and categorizing generative grammar struc-
tures. Here we utilize formal language theory to produce the following grammar which
8
yields a recursively enumerable context sensitive language.[3]
Definition Let the grammar LT (G) be a tuple, {V,
?
, R, S}. S ? V,
?
2 ?
?
,
?
3
?
?
,
?
4 ?
?
, such that:
V
? ?
= ?,
V={S, T, A, B, C, Q, U},?
={ ?, 0, 1, 0 , 1 , [, ] },?
2={0,1},?
3={0,1},?
4={ ?, 0, 1, 0 , 1 , [, ] },
R={S?? ?, S??T, T???, T??A, T??B, T??C, T??Q, A??1, A??0, A??0A,
A??1A, A??0C, A??1B, B??0, B??0A, B??0 , B??0C, C??1, C??1A, C??1B,
C??1 , Q??[Q], Q??[U], Q??T[U]T, Q??T[U]T[U]T, U??01B, U??10C, U??0A,
U??1A, U??0C, U??1B}
Definition Let LT be a language of the elements in
??
4 which generate only from
grammars generated by the non-terminals B, C, Q and U that cannot be generated
exclusively by the non-terminal A. Let the elements of
??
4 have an onto mapping to
the recursive strings of infinite length in
??
3 (i.e. those strings from
??
3 which are
readable by Bu?chi automaton). [1]
Definition We define ?? as the set of all well formed strings over LT .
Lemma ?? is an Abelian Group
2.2.3 Addition in ??
Definition LENGTH(x) is a function which outputs the length of a string within
brackets.
Definition PLUS1(w) = w + 1 = 1 + w and follows these rules:
PLUS1(0) := 1
PLUS1(1) := 10
PLUS1(1 ) := 0
PLUS1(0 ) := 0 1
PLUS1([10]) := [10]11
PLUS1([01]) := [01]10
PLUS1([1 0]) := [1 0]1
PLUS1([0 1]) := [0 1]0
PLUS1([01 ]) := [01 ]0 10
PLUS1([10 ]) := [10 ]1
9
Definition PLUS1 (w) = w + 1 = 1 + w and follows these rules:
PLUS1 (0) := 1
PLUS1 (1) := 0
PLUS1 (1 ) := 1 0
PLUS1 (0 ) := 1
PLUS1 ([10]) := [10]01
PLUS1 ([01]) := [01]00
PLUS1 ([1 0]) := [1 0]1
PLUS1 ([0 1]) := [10 ]
PLUS1 ([01 ]) := [1 0]
PLUS1 ([10 ]) := 1 [01 ]
Definition Let PLUS() be commutative such that PLUS(w1, w2) = w1+w2 = w2+w1,
and follows these rules:
PLUS(w10, w20) := PLUS(w1, w2)0
PLUS(w11, w20) := PLUS(w1, w2)1
PLUS(w10, w21) := PLUS(w1, w2)1
PLUS(w11, w21) := PLUS1(PLUS(w1, w2))0
PLUS(w11 , w20 ) := PLUS(w1, w2)1
PLUS(w10 , w21 ) := PLUS(w1, w2)1
PLUS(w11 , w21 ) := PLUS1(w1, w2))0 1
PLUS(w10 , w20 ) := PLUS(w1, w2)0
PLUS(w11 , w21) := PLUS(w1, PLUS1 (w2))0
PLUS(w11 , w20) := PLUS(w1, PLUS1 (w2))1
PLUS(w10 , w20) := PLUS(w10 , w2)0
PLUS(w10 , w21) := PLUS(w10 ,w2)1
PLUS(w1[x0], w20) := PLUS(w1[0x], w2)0
PLUS(w1[x0], w21) := PLUS(w1[0x], w2)1
PLUS(w1[x1], w20) := PLUS(w1[1x], w2)1
PLUS(w1[x1], w21) := PLUS(PLUS1(w1[0x]), w2)0
PLUS(w1[x0], w21 ) := PLUS(PLUS1 (w1), w2)[PLUS1 (x)1]
PLUS(w1[x1], w21 ) := PLUS(PLUS1 (w1), w2)[PLUS1 (x)0]
PLUS(w1[x0 ], w21 ) := PLUS(PLUS1 (w1), w2)[PLUS1 (x)1 ]
PLUS(w1[x1 ], w21 ) := PLUS(PLUS1 (w1), w2)[PLUS1(x)1 0]
PLUS(w1[x1 ], w20 ) := PLUS(w1[1 x, w2)1 ]
PLUS(w1[x0 ], w20 ) := PLUS(w1, w2)[x0 ]
Remark Similarly, brackets may also appear in w2, but details are omitted for the
sake of brevity.
Definition To define the set P?, let us suppose Kleene star expansions of strings
10
over ??: ‘(w1)*([(w2)*])*(w3)*’ and an expansion rule such that when there exists the
terminal 0 in a string, there can be a Kleene star expansion of ‘0’ either to the left or
the right or both of 0 such that ‘0*0 0*’ is a valid string and similarly for 1 such that
‘1*1 1*’ is a valid string. P? is the union of ?? and all such Kleene star expansions in ??.
Definition Let an ?-expansion of a string be an infinite iteration operator similar to
a Kleene star expansion, but for infinite words.
Definition LENDIFF( ): For all x in strings w3, w4:
LENDIFF(LENGTH(x1)*LENGTH(x2)) := LENGTH(xy) where xy is a concatena-
tion of x1 LENGTH(xy) times.
LENDIFF(LENGTH(x1)*LENGTH(x2)) := LENGTH(xz) where xz is a concatena-
tion of x2 LENGTH(xz) times.
When LENGTH(x1) != LENGTH(x2):
Definition PLUS(w1[xy], w2[xz]) := PLUS(w3, w4)
Remark Addition is Commutative: By the definition of the PLUS function, addition
is commutative in ??; the equation a+ b = b+ a holds for all a, b in ??.
Remark It is easy to allow addition to be associative in ?? such that the equation
(a+ b) + c = a+ (b+ c) holds for all a, b and c in ??.
Remark The identity element exists as 0, for all w:
PLUS(w, 0)=w
Definition Let String Equality be the condition where expanded strings from a formal
language, either by Kleene star expansions or ?-expansions, have equality with strings
from which they expanded.
Definition Let w1 be a string from ?
? and let w2 be a string expanded from w1 such
that for every symbol 0 in a string, there is string equality when 0 = 0 0* and 0 =
0 0?. There is also string equality when for every symbol 1 in a string, 1 = 1 1* and
1 = 1 1?.
Definition Let P? be all the strings in ?? union all ?-expansions and Kleene star
expansions of symbols in P?. Because of string equality, for w1 in ?
? and for w2 in P
?
PLUS(w1, 0) := PLUS(w2, 0).
Definition Let P8 be all strings in P? which are not in ??.
Proposition Addition in ?? is closed. PLUS( ) will only yield answers in ?? or P8
11
by the function PLUS( ). For any strings w1 ? ??, w2 ? ??, PLUS(w1, w2):=wa, if
wa ? P8, there exists a String Equality in ??, such that wa = wb where wb is in ?? and
PLUS(w1, w2):=wb through reflexivity. Since wb /? P8, it must be in ??. Therefore,
addition is closed in ??.
Proposition There is an additive inverse for each w ? ??. For every wx, there exists
some wy through iteration in PLUS(wx, wy) such that the output string will be some
combination of terminals 0* and 0 *, which through String Equality=0.
Lemma. ?? is an Abelian Group under addition. From the previous two proposi-
tions, and because or definition of PLUS( ) includes commutativity, by the definition
of an Abelian Group as having closure, associativity, an identity element, an inverse
element and commutativity, ?? is an Abelian Group under addition. 
2.3 A Non-trivial Counterexample to Cantor’s Diagonal Ar-
gument
2.3.1 Formalizing a Diagonal Argument Function
For Cantor’s Diagonal Argument, one may generalize an argument function, for proof
by contradiction, through constructing an arbitrary sequence of infinite length strings
in any order into an N by N matrix of symbols and assuming all rows of the matrix
contains all string values. Then, one proceeds to the ithcolumn, jth row of the matrix,
where (i, j ) moves along the diagonal of the matrix- (1,1), (2,2), (3,3)... etc. The
symbol at that position is then changed to a different symbol within the language of
the system and concatenated to produce a new string, which when so constructed,
the new string of symbols can’t be found in any row or column of the matrix, thus
providing a string of a value not listed in the matrix. The new string is considered
transcendental in Cantor’s Universe and the proof by contradiction tells us that not
every string value can be calculated in Cantor’s Universe through iterative process,
and as such, R is “uncountable” and has a cardinality strictly larger than N. This
is necessarily true for all constructions of the diagonal argument prior to the method
employed in this paper because the ith string must contain the symbol found at (i, j )
which can not be in the constructed string at (i, j ) from the diagonal and there did
not yet exist a mapping relationship suitable for counterexample to CDA. [3]
The following construction maps the set ?? with equivalent strings in P?, showing
that the diagonal argument applied to a special ordering of subsets in P?, yields a
non-trivial counterexample to Cantor’s argument function.
Remark It should be noted that because the elements of P? are not the Real numbers,
and thus, the trivial exception where .9?=1 is not a concern because this evaluation or
any equivalent evaluation does not exist in P? by construction and this exception sim-
ply cannot occur. We will not concern ourselves with this exception, since it is a special
case, it is considered trivial. However, if such a case could be generalized, it would no
12
longer be trivial.
2.3.2 Additional Notations and Preliminaries
Consider a proof by contradiction as an argument function f (S ) over a set S yielding a
domain f(S)? g(S) and some countable set of matrices reducible via Cantor Pairing
to size N× N, {f (S )}, to which we will apply an argument function f (S ).
Definition A counterexample to an argument function (which is a proof by contradici-
ton), is the condition when there exists f (S )?g(S ) such that for any g(S )? {f (S )} iff
g(Q)/? {f (Q)} OR if any g(S )/? {f (S )} iff g(Q)? {f (Q)} for sets S and Q.
Definition Let right-concatenation be the concatenation operator * such that when
w1 right concatenates over w2, w1*w2=w2w1 and likewise, w1*w2*w3*w4=w4w3w2w1
Definition Let str(f ( xj ) ) be the cumulative string of the output of the function
f (xj)* f (xj?1)* f (xj?2)... *f (xj?j). Similarly for str(g( xj ) ).
Definition Let the argument function f (R) be a construction of Cantor’s diagonal
method on the N × N matrix {f (R)} of arbitrary unbounded binary strings. They
are listed in any order, assuming that all possible string values of R are listed. Let
g(R)=str(g(xj)) where xj is the value, 0 or 1 at the coordinate (i,j ) for all j on the
constructed matrix at row j such that j=i. It is well established that in Cantor’s
Universe, g(R)/? {f (R)}, and we can produce a string which is in R but not in {f (R)}.
For counterexample, since we accept g(R)/? {f (R)}, we must find some set of re-
cursively enumerable sets or set of uncountable sets S where g(S) ? {f (S)}.
Definition Let the argument function f (P?0 ) be an equivalent construction of Can-
tor’s diagonal method where a series of N × N matrices, {f (P?0 )}, is partitioned into
two specially ordered matrices, {f (P?1 )} and {f (P?2 )}. {f (P?1 )} ? {f (P?0 )} and {f (P?2 )}
? {f (P?0 )}. These two partitions will be proper disjoint subsets of {f (P?0 )} such that
{f (P?1 )}
?
{f (P?2 )}={f (P?0 )}.
Construct the argument function for application of CDA to P?0 , {f (P?0 )}, in the follow-
ing manner: Let ?? map to two sets, ??1 and ?
?
2, through choice, choosing the strings
in ??1 as all the strings where each string is denoted by the initial with Kleene star
expansions, from left to right as follows: 0w, 0w, [?0w or [?0w. And likewise, choose
the strings in ??2 as all the strings where each string is denoted by the initial, from left
to right, 1w, 1w, [?1w or [?1w, thus creating a strictly bijective disjunction between
the sets whose union is ??. Choose some string set in ??1 such that it maps to an infinite
length string by String Equality in P? to form the set P?1 . Choose some string set in
??2 such that it maps to some infinite length string by String Equality in P
? to form
the set P?2 . Let the union of P
?
1 and P
?
2 be P
?
0 .
We will begin the proof of the existence of the counterexample to CDA by proceeding
13
with a construction of f (P?1 ) and f (P
?
2 ) individually, and then providing a retrograde
on str(g(P?2 )) to construct the diagonal of {f (P?0 )}.
2.3.3 Theorem
Proof. There is a Non-trivial Counterexample to Cantor’s Diagonal Argument.
1. ?? is an Abelian group by Lemma.
2. By String Equality we can create an Abelian Relationship in all extended sets
related to ?? by providing an operation on a string in ?? to yield another result
in ??, which can then be made equal to some string in P? and its subsets, thus
allowing for special order, utilizing exhaustion, if necessary.
3. We will choose the elements of P?1 and P
?
2 in such a way, that when proceeding
with the argument function down the diagonal of the respected matrices, {f (P?1 )}
and {f (P?2 )}, we will encounter only the symbols 0 and 1, respectively. This can
be ensured by expanding other symbols when necessary. We will reserve the
axiom of replacement if necessary when forming the sets to aid in our choice for
the rows in the respective matrix sets.
4. Proceeding to f(P?1 ), we choose to write the row, j = 1, as some 01 as it’s defined
mapped string, 01 1? and by the argument function, utilize the symbol from the
1st column of this row such that f (x1):=0 and str(g(x1)):=1.
5. Choose in the set such that the second row in {f (P?1 )} is 01=0 0?1?1 and
f (x2):=0, and str(g(x2)):=11 in accordance with the argument function.
6. Thus, through ?-completion of the recursive iterations resulting in an unbounded
series, for all j in {f (P?1 )}, f (xj):=0; g(xj):=1.
7. It follows through String Equality that g(P?1 )=1 .
8. Likewise, proceeding to f(P?2 ), we choose to write the row, j = 1, 10 as it’s
defined mapped string as some 10 0? and by the argument function, utilize the
symbol from the 1st column of this row such that f (x1):=1 and str(g(x1)):=0.
9. Choose in the set such that the second row in {f (P?2 )} is 10=1 1?0?0 and
f (x2):=1, and str(g(x2)):=00 in accordance with the argument function.
10. Thus, through ?-completion of the recursive iterations resulting in an unbounded
series, for all j in {f (P?2 )}, f (xj):=1; g(xj):=0.
11. It follows through String Equality that g(P?2 )=0 .
12. The retrograde of g(P?2 )=0 is reflexive, 0 .
13. The special order of {f (P?0 )} is the special order of {f (P?1 )} union the retrograde
of the special order of {f (P?2 )}, allowing for an inversion on the strings in the
diagonal, because of retrograde, for consistency in the argument function.
14. Through String Equality, g(P?0 )=10
15. By choice of {f (P?2 )} which is a subset of {f (P?0 )}, as illustrated by step 9 in this
proof, the string 10=1 1?0?0 is in {f (P?0 )}.
16. Therefore, there exists a counterexample; when g(R) /? R, g(P?0 ) ? P?0 .
y
14
2.4 Discussion
We can easily generalize this counterexample for all elements in ?? by choosing the
appropriate ordering of the list of elements used for constructing the diagonal.
Finding such a non-trivial counterexample to CDA provides a new understanding
about the limits of computability and these results confirm the flaw found in the
Entscheidungsproblem. It would be wise for logicians, mathematicians and computer
scientists to revise all their texts accordingly. However, I recognize that this is quite an
ordeal, so we will venture one step further, beyond what would be required of any other
paper or result, and provide a third argument as it relates to Go?del’s Diagonalization
Lemma, which is a third method that differs from the previous two already discussed,
but is reducible to the same result.
3 Go?del’s Diagonalization Lemma is Not Logically
Contingent
3.1 Some Impredicative Statements Reduce to Circular Logic
An impredicative statement is a statement with self-referencing. Self-reference alone
is not enough to invalidate a proposition, however, as we will show, a certain class of
impredicative statements are intrinsically circular and tautological. Such circular logic
is not well-formed for proof of a proposition which depends on its circular nature, and
is thus not logically contingent.
In this section, we will show that Go?del’s Diagonalization Lemma is within this
class of impredicative statements. We will then review this lemma and show that
his utilization of substitution is not strict enough for a strong foundation in logic.
Furthermore, we will actually construct the Go?del numbers suitable for his proof, and
carry out the operations to see if indeed such arithmetic is outside of a formal system,
Q.
First, we must determine a means to identify when a tautology is present in an
impredicative definition. Let’s start with an example of a tautology. We would not
accept the following as a logical statement as true in any meaningful way (it is, in fact,
”true” semantically), because there is no proof or causal relationship, only tautology:
(S ? ¬S)
We can determine if a statement is a tautology or not, by creating a truth table
over the distinct valuations for the formula. If all valuations for each variable lead to
truth, then the statement is a tautology.
For (S ? ¬S), When S is true, (S ? ¬S) is true. When S is false, (S ? ¬S) is true.
Thus, (S ? ¬S) is a tautology.
So what about impredicativity? Intuitively, it is easy to see how we risk creating
a tautology by using such a tactic to define one’s terms: Self reference intrinsically
eliminates the possibility for that variable to contradict itself, increasing the likelihood
of tautology.
However, self-reference or impredicativity alone, is not enough to prove tautology.
For example, the greatest lower bound (glb) of a set, can be defined impredicatively, y
= glb(X) if and only if for all elements x of X, y is less than or equal to x, and any z
15
less than or equal to all elements of X is less than or equal to y. [8] This definition is
impredicative, but it is not tautological.
But now, intuitively, before we prove for GDL, I would like to claim that Russell’s
paradox uses an impredicative definition that is itself actually tautological.
Define S as the set of all sets that do not contain themselves. This is impredicative,
and it is tautological, because there seems to be this infinite self-referencing that goes
on when we apply S to itself.
So what differentiates these two classes of impredicative definitions from each other?
Heuristically, in the first instance, we are using the set of X to define y, which is the
greatest lowest bound of X. In the second instance, we are defining S as a set defined
by sets. When we apply the distinguishing property to the definition that makes the
term unique, in the instance of the greatest lowest bound, the property is not applied
to the impredicative portion of the statement. Rather, the property is applied to an
independent portion. That is, the property of being an element is distinguished from
the property of being a set, the set, in this instance, being the impredicative portion
of the statement.
In Russell’s paradox, the property of being a set that does not contain itself, is
a property applied to a dependent portion of the impredicative statement, that is,
the property when applied to sets in general, also applies to the specific set we are
defining. This dependence of the property of the set on the set, is the distinguishing
factor. I believe it was Wittgenstein, at a dinner party with Russell, who first noted
that Russell’s paradox is easily overcome by defining a class of sets that do not contain
themselves. When you define a class of sets, you break the dependence of it as a set
(since it is no longer a set, but a class) with given properties that apply to sets.
But I believe this heuristic falls short. It is not just this dependence that creates
a tautologial impredicative statement, it is also the nature of the property itself. We
could easily define the set of all sets which contain the letter A. Such a definition has
a dependence on impredicative portion of the statement, yet does not seem to create
create a tautology or an infinite regression or anything of that sort. That is, in order
to create a tautology, A itself would have to be defined, not only in terms of sets, but
in terms of the class of sets in question. As such, in order for impredicatives to be a
problem for logic, the property itself must point back to the impredicative dependence
in a self referential way.
Definition Let impredicative dependence be the condition of a statement S, whose
property P depends on self-referencing. ?x|P (x)? {x? P (x)}
Definition Let impredicative pointing be a condition of self-reference where a depen-
dent property also references an impredicative dependence, i.e. the existence of S
depends on S containing an impredicative dependence. ?x|P (S) ? P (x) ? {x ?
P (x)} ? S
Definition Let a tautological impredicative be a statement which satisfies impredicative
pointing. ?x|P (S)? P (x)? {x? P (x)} ? S
Proposition Tautological impredicatives are logical tautologies. S  ?x|P (S)? {x?
16
P (x)} ? S
The final statement S is always true, even when S is assumed to be false.
S x P(S) ? {x ? P(x)} ? S
true true true
true false true
false true true
false false true
3.2 Go?del’s Diagonalization Lemma Depends on a Tautological
Impredicative
Go?del’s Diagonalization Lemma states that there is a sentence ? such that ? ?
F (o#(?)) is provable in Q where o#(?) is the Go?del number for ? and F is some well
formed formula provable in a formal system Q.
It is clear to see that the statement concerning ? is a tautological impredicative,
as Go?del derives ? by the following proof.
3.2.1 Go?del’s Diagonalization Lemma
Proof : Q ` ?? F (o#(?)).
Given a formula with one free variable, F(x) in Q and a number n, we may substitute
some number n for x. We may also represent the formula F(x) by the Go?del number of
the formula, o#(F (x)) and of a number n, and that it is possible that n :=o #(F (x)),
but note that it is impossible that n :=o #(F (n)) We can refer to this process of sub-
stitution by the function substn(o#(F (x)), n) :=o #(F (n)). We can also let S(x, y, z)
be a formula which strongly represents this operation in the language of Q if and only if:
x =o #(F (x)), y = n, and z =o #(F (n))
Nothing prevents y := x, such that we may have the formula S(x, x, z).
Given any formula F(x), we may also create the formula ?z[F (z)?S(x, x, z)] with one
free variable, x. This formula has the Go?del number k =o #(?z[F (z) ? S(x, x, z)]) At
this point, we may substitute k for x, such that ?z[F (z) ? S(k, k, z)]
Let ? := ?z[F (z) ? S(k, k, z)]
Let m =o #(?z[F (z) ? S(k, k, z)])
Q ` ?z[S(k, k, z)? z = m]
Q ` ?z[S(k, k, z)? z =o #(?z[F (z) ? S(k, k, z)])
Q ` ?? ?z[F (z) ? z =o #(?z[F (z) ? S(k, k, z)]) and from this...
Q ` ?? F (o#(?z[F (z) ? S(k, k, z)]), which is
Q ` ?? F (o#(?)) [6]
Remark. Bew() is short for the german word beweisbar, which means “provable”.
Note that “Bew(x)” is merely an abbreviation that represents a particular, very long,
formula in the original language of Q; the string “Bew” itself is not claimed to be part
17
of this language.[9]
Ok, fine. This seems logical, but what happens when F (x) := ¬Bew(x)?
We get Q ` ? ? ¬Bew(o#(?)). This is a contradiction. The proper question,
given the previous two section in this article, is to ask, why do we have such a contra-
diction arise? Is it because of incompleteness, or is it a result which only exists because
of a fundamental flaw in the diagonalization lemma, which creates a logical tautology?
I wish to point out, that if ¬Bew(x) applies to ?, then, this is the function which
must also apply to z.
Such that ¬Bew(?)? ¬Bew(z), where:
z =o #(?z[¬Bew(z) ? S(k, k, z)]) thus,
Q ` ?? ¬Bew(o#(?z[¬Bew(z) ? S(k, k, z)])), directly implies
Q ` ¬Bew(o#(¬Bew(z))), which is obviously a self-contradiction.
which means that the fundamental assumption we made about there existing a func-
tion F (x) with one free variable, is what is incorrect... that it is through improperly
initiating substitutions, when we create tautology, which allows contradiction. This is
a fundamental problem with the logic used in Go?del’s proof, not necessarily Q. There
could be some Q where stronger foundations in logic is mandatory. Furthermore, we
can easily see that Q allows tautological impredicatives by proving ?.
3.2.2 Q ` ?? F (o#(?)) is a Tautological Impredicative
Let the formal system Q be represented by the statement S in Q.
Let o#(x) be the property P (x), such that
Q ` ?? F (o#(?)) := S ` ?? F (P (?)), then
?? S ` ?z[F (z) ? S(k, k, z)],
since k ? P (x),
and z ? k ? P (P (x)),
then P (x)? P (P (x))? z, which proves impredicative dependence, our first condition
of tautological impredicativity.
If ?? ?z[F (z) ? S(k, k, z)], and P (x)? P (P (x))? z,
then ?? {P (x)? P (P (x))} ? z, thus,
P (z)? {P (x)? P (P (x))} ? ?, and since
?? z,
P (?) ? {P (x) ? P (P (x))} ? ? which satisfies our definition of a tautological im-
predicative, which means that GDL is a logical tautology and his proof can not be
logically contingent. y
18
3.2.3 Discussion
Did Go?del overstep in his logic by taking too many liberties with free variables?
The answer to such a question, is perhaps a matter of opinion. It is either OK to
prove the existence of statement which is a logical tautology in a formal system, or
it is not. If it is OK, I think we would have to also assume it would be difficult to
prevent such a tautology from occurring, or that tautologies must be desirable in logic.
However, because tautologies are not desirable, as they open up systems to paradox,
meaninglessness and contradiction, I believe it would be of a higher opinion to seek out
a rule which invalidates their existence in a consistent system; that any system which
can prove tautologies, is in fact inconsistent.
Such a rule is relatively easy to find. It seems, unless one can offer an additional
example than the one provided by Go?del, that tautologies in a formal system such as
Q, are only made possible by misusing substitution over a free variable. Substitution,
being an important foundational element in logic, is not itself in question. But rather,
a limit on how substitution may be applied, perhaps should be.
We could just create a postulate or axiom which makes x a bounded variable after
substitution.
Such a postulate will allow some impredicative statements, all of which can avoid
tautology, but through preventing re-substitution on x, will prevent impredicative
pointing, and thus prevent tautologies from forming in Q. Thus, creating a much
stronger foundation to our systems of logic and computability.
Or, if such a postulate is too restrictive, we can modify the limit of substitution
over bounded x, not to substitution in general, but to statements from the free variable
x, formally as follows:
Axiom. For any formal systemQ, with a free variable x in formula A(x), after substitu-
tion is applied to x, x is bounded by the substitution function such that subst(subst(x))
!= subst(x).
Such a rule will strengthen, not weaken the logical prowess of humanity.
4 Conclusion, P=NP
While only one method was ever truly necessary, by three novel, independent and
rigorous methods, we have been able to deconstruct one of the key foundations of
mathematics and computer science, diagonalization. In Section 1, we constructed
an impossible Supermachine which should not exist, yet it does. In section 2, we
constructed a formal language which yields a non-trivial counterexample to Cantor’s
Diagonal Argument. And in Section 3, we tackled the impredicative nature of Go?del’s
diagonalization lemma, revealing a tautology, which is logically unfounded. Again, any
one method should have been enough for proof, but because of the significance of such
a finding, I decided to combine over a decades worth of research and original thought
into this single cohesive, self-contained paper.
19
Finally with diagonalization methods invalid, the entire complexity hierarchy col-
lapses, and we now have a foundation in computer science where there is enough
information to solve the P vs. NP problem. Without diagonalization, our reasons for
not using an oracle to solve P vs. NP vanish, as the contradictions which formally
prevented the use of such oracle no longer exist. It was inconcsistency, through the use
of diagonalization that lead to Hierarchy results which created oracle contradictions.
Lemma. If PSPACE = EXPSPACE, P = NP . If the SPACE of a problem in-
creases polynomially as with any PSPACE-complete problem, this is comparable to
the TIME of a problem increasing polynomially, such that given an oracle, =poly,
which solves polynomial equivalence between SPACE and TIME, PSPACE =poly P .
Similarly, if the SPACE of a problem increases exponentially as with any EXPSPACE-
complete problem, this is comparable to NP which is at maximum, in exponential
TIME, such that EXPSPACE >=poly NP . If PSPACE = EXPSPACE, then
PSPACE >=poly NP . Since PSPACE =poly P , P >=poly NP , which is the same
as P = NP .
Solving for ?
?
in Section 1 is RE complete, and because the Space Hierarchy The-
orem relies fully on the now defunct diagonalization method, its results must be dis-
carded.
And as such, with the Entschiedungsproblem being RE-complete, and since we may
solve for arbitrary ?
?
using the Supermachine configuration, we may now conclude:
Proof. Since by definition, PSPACE ? RE, and
since any given Recursively Enumerable set is contained in PSPACE,
and ?
?
solves for all Recursively Enumerable sets in PSPACE,
and since we can no longer accept the Space Hierarchy Theorem,
RE ? PSPACE ...
RE = PSPACE,
such that EXPSPACE ? RE
and RE = PSPACE, implies
PSPACE = EXPSPACE, proves through the above Lemma ...
P = NP y
Mark Inman, Ph.D.
Prague, Czech Republic
References
[1] Bu?chi, J.R., On a decision method in restricted second order arithmetic. Proc.
International Congress on Logic, Method, and Philosophy of Science. 1960, pages
1–12, Stanford, CA, Stanford University Press. 1962
[2] Lewis, Harry Introduction to Formal Systems and Computation CS121 Harvard
College December 2007 http://www.seas.harvard.edu/courses/cs121
20
[3] Sipser, M. Introduction to the Theory of Computation, 3rd ed., Cengage Learning,
Boston 2013
[4] Staiger, L., ?-Languages G. Rozenberg and A. Salomaa, editors, Handbook of For-
mal Languages, Volume 3, pages 339-387. Springer-Verlag, Berlin, 1997.
[5] Suppes, Patrick Axiomatic Set Theory Mineola, NY: Dover Publications, Inc. 1972
[6] https://plato.stanford.edu/entries/goedel-incompleteness/sup2.html
[7] A. M. Turing “On Computable Numbers, with an Applcation to the Entschei-
dungsproblem” 1936-1937: Proceedings of the London Mathematical Society, Series
2, 42, pp 230?265.
[8] https://en.wikipedia.org/wiki/Impredicativity
[9] https://en.wikipedia.org/wiki/Go?del’s incompleteness theorems
21
